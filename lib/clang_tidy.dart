import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart';
import 'logger.dart';
import 'common.dart';

class TidyReplacement {
  int rmLength;
  int line;
  int cols;
  int offset;
  String text = "";

  TidyReplacement(this.offset, this.line, this.cols, this.rmLength);
}

/// A class to represent a single reported clang-tidy diagnostic for a file.
class TidyDiagnostic {
  /// The identifying [name] of the clang-tidy diagnostic.
  String name;
  int offset;
  String message;
  String level;

  /// Create an object to represent a clang-tidy diagnostic.
  TidyDiagnostic(this.name, this.offset, this.message, this.level);

  int line = 1;
  int cols = 0;
  List<TidyReplacement> replacements = [];

  /// Get a suggestion (in markdown format) for the diagnostic in accordance to
  /// the clang-tidy list of replacements. Returns `null` if no replacements
  /// were generated by clang-tidy (some diagnostics don't have auto fixes).
  String? suggestion(String content, List<int>? linesChanged) {
    if (replacements.isEmpty) return null;
    var replaced = '';
    var lastOffset = 0;
    for (final replacement in replacements.asMap().entries) {
      if (linesChanged != null &&
          !linesChanged.contains(replacement.value.line)) {
        continue;
      }

      if (replaced.isEmpty) {
        // making our first replacement
        replaced = content.replaceRange(
          replacement.value.offset,
          replacement.value.offset + replacement.value.rmLength,
          replacement.value.text,
        );
        lastOffset = replacement.value.offset + replacement.value.text.length;
      } else {
        // making a subsequent replacement.
        var adjustedOffset = 0;
        // We need to know how much the content has changed from previous
        // replacements (about this diagnostic).
        for (final prev in replacements.take(replacement.key)) {
          adjustedOffset += prev.text.length - prev.rmLength;
        }
        replaced = replaced.replaceRange(
          adjustedOffset + replacement.value.offset,
          adjustedOffset +
              replacement.value.offset +
              replacement.value.rmLength,
          replacement.value.text,
        );
        lastOffset = adjustedOffset +
            replacement.value.offset +
            replacement.value.text.length -
            replacement.value.rmLength;
      }
    }
    var lineStart = replaced.lastIndexOf('\n', offset) + 1;
    var lineEnd = replaced.indexOf('\n', lastOffset);
    assert(lineEnd >= lineStart);
    return '```suggestion\n${replaced.substring(lineStart, lineEnd)}\n```';
  }
}

/// A class to represent clang-tidy advice about a single file.
class TidyAdvice {
  /// The [FileObj] corresponding to the clang-tidy advice
  final FileObj file;

  /// Create an object to represent clang-tidy advice about a [file].
  TidyAdvice(this.file);

  /// The [List] of clang-tidy diagnostics about the file.
  List<TidyDiagnostic> diagnostics = [];

  void logCommand({bool lineChangesOnly = false}) {
    var linesChanged = file.additions;
    for (final diag in diagnostics) {
      // This check for line changes may seem redundant since it was already
      // done when parsing the YAML fixes, but some advice may have originated
      // from lines not changed.
      if (lineChangesOnly && !linesChanged.contains(diag.line)) {
        continue;
      }
      logCommander.info(
        '::${diag.level.startsWith('note') ? 'notice' : diag.level.toLowerCase()}'
        ' file=${file.name},line=${diag.line},title=${diag.message}:'
        '${diag.line}:${diag.cols} [${diag.name}]::${diag.message}',
      );
    }
  }

  List<String> getSuggestions({bool lineChangesOnly = false}) {
    var linesChanged = lineChangesOnly ? file.additions : null;
    var content = File(file.name).readAsStringSync();
    var results = <String>[];
    for (final diag in diagnostics) {
      var advice = diag.suggestion(content, linesChanged);
      if (advice != null) {
        results.add(advice);
      }
    }
    return results;
  }
}

TidyAdvice parseYmlAdvice(FileObj file, {bool lineChangesOnly = false}) {
  var yml = loadYaml(File(clangTidyYamlCache).readAsStringSync()) as Map;
  var yamlAdvice = TidyAdvice(file);
  List<int>? changed = file.additions;
  for (final diagnostic in yml['Diagnostics']) {
    String type = diagnostic['DiagnosticName'];
    String level = diagnostic['Level'];
    var message = diagnostic['DiagnosticMessage'] as Map;
    String text = message['Message'];
    YamlList replacements = message['Replacements'];
    int offset = message['FileOffset'];
    String path = message['FilePath'];
    var tidyDiag = TidyDiagnostic(type, offset, text, level);
    var (line, cols) = getLineAndColsFromOffset(path, offset);
    tidyDiag.line = line;
    tidyDiag.cols = cols;
    yamlAdvice.diagnostics.add(tidyDiag);
    for (final replacement in replacements) {
      String rPath = replacement['FilePath'];
      int offset = replacement['Offset'];
      (line, cols) = getLineAndColsFromOffset(rPath, offset);
      if (lineChangesOnly && !changed.contains(line)) {
        continue;
      }
      var rmLength = replacement['Length'];
      var tidyReplace = TidyReplacement(offset, line, cols, rmLength);
      tidyReplace.text = replacement['ReplacementText'];
      tidyDiag.replacements.add(tidyReplace);
    }
  }
  return yamlAdvice;
}

/// A class to represent clang-tidy notifications (parsed from the stdout of a
/// dry run).
class TidyNotification {
  /// The file's name corresponding to the notification.
  final FileObj file;

  /// The line number about the notification.
  final int line;

  /// The column number on the line about the notification.
  final int cols;

  /// The priority level of the notification.
  final String type;

  /// The human-friendly text describing the diagnostic about the notification.
  final String info;

  /// The clang-tidy diagnostic name that triggered the notification (as given
  /// to clang-tidy's `-checks` arg).
  final String diagnostic;

  /// A list of source lines about the notification. Some diagnostic prompts do
  /// not include this, so this list may be empty.
  List<String> srcLines = [];

  /// Create an object to represent a clang-tidy notification.
  TidyNotification(
    this.file,
    this.line,
    this.cols,
    this.type,
    this.info,
    this.diagnostic,
  );

  String logCommand(bool linesChangedOnly) {
    if (linesChangedOnly && !file.additions.contains(line)) return '';
    return '::${type.startsWith('note') ? "notice" : type} file=${file.name},'
        'line=$line,title=${file.name}:$line:$cols [$diagnostic]::$info';
  }
}

List<TidyNotification> parseTidyOutput(FileObj file, String output) {
  var notifications = <TidyNotification>[];
  for (final line in output.split('\n')) {
    var match = RegExp(r"^(.+):(\d+):(\d+):\s(\w+):(.*)\[([a-zA-Z\d\-\.]+)\]$")
        .matchAsPrefix(line);
    if (match != null) {
      // starting a new notification
      // var filename = p.relative(match[1]!).replaceAll('\\', '/');
      var line = int.parse(match[2]!);
      var cols = int.parse(match[3]!);
      var noteType = match[4]!;
      var noteInfo = match[5]!;
      var diagnostic = match[6]!;
      notifications.add(
        TidyNotification(
          file,
          line,
          cols,
          noteType,
          noteInfo,
          diagnostic,
        ),
      );
    } else {
      assert(notifications.isNotEmpty);
      notifications.last.srcLines.add(line);
    }
  }
  return notifications;
}

Future<List<TidyNotification>> runClangTidy(
  FileObj file,
  String version,
  String style,
  String checks,
  bool linesChangedOnly,
  String database,
  List<String>? extraArgs,
  bool debug,
) async {
  File(clangTidyYamlCache).writeAsBytesSync([]);
  if (checks == '-*') return <TidyNotification>[];
  var exe = makeClangToolExeVersion('clang-tidy', version);
  var args = [
    "--export-fixes=${clangTidyYamlCache.replaceAll('/', p.separator)}",
    '--format-style=${style.isEmpty ? 'none' : style}',
  ];
  if (checks.isNotEmpty) args.add("--checks='$checks'");
  if (database.isNotEmpty) {
    args.addAll(
        ['-p', p.isRelative(database) ? p.absolute(database) : database]);
  }
  var ranges = file.linesAdded;
  if (ranges.isNotEmpty) {
    var lineFilter = {
      "name": file.name.replaceAll('/', p.separator),
      "lines": ranges
    };
    args.add('--line-filter=[${jsonEncode(lineFilter).toString()}]');
  }
  if (extraArgs != null && extraArgs.isNotEmpty) {
    for (var arg in extraArgs) {
      args.add('--extra-args=$arg');
    }
  }
  args.add(file.name.replaceAll('\\', '/'));
  log.info('Running "$exe ${args.join(' ')}"');
  var stderrLines = <String>[];
  var result = await subprocessRun(exe,
      args: args, captureStderr: stderrLines, allowThrows: false);
  if (debug) File(clangTidyNoteCache).writeAsStringSync(result);
  if (stderrLines.isNotEmpty) {
    log.config(
      'clang-tidy made the following summary:\n\t${stderrLines.join("\n\t")}',
    );
  }
  return parseTidyOutput(file, result);
}
